---
timestamp: 'Thu Oct 23 2025 22:35:17 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251023_223517.c11a8824.md]]'
content_id: 4c156f9166a70096cac84b6f993e79c64866c6ba2451d4fdcef08ae64e12ccbb
---

# UserAuthentication

**concept** UserAuthentication \[User]

**purpose** Enable users to securely identify themselves, establish active sessions, and manage their access credentials for this and other integrated systems.

**principle** If a new user registers with a unique username and password, they can then log in with those credentials to establish an active session, allowing them to perform actions as that authenticated user. When logged in, they can securely store and retrieve credentials for other systems, which remain inaccessible when logged out.

**state**
a set of Users with
username: String
hashedPassword: String // Stores the hash of the user's password
additionalCredentials: Map\<String, String> // Maps credential type (e.g., "Canvas") to an encrypted credential value

a set of activeSessions with
user: User // The authenticated user
sessionToken: String // A unique identifier for the active session

**actions**
// Assumed: `hash(password)` is a secure one-way hashing function

register (username: String, password: String): (user: User)
**requires** not (exists User u where u.username = username)
**effects**
create new User called newUser
newUser.username := username
newUser.hashedPassword := hash(password)
newUser.additionalCredentials := an empty Map
return user := newUser

register (username: String, password: String): (error: String)
**requires** exists User u where u.username = username
**effects** return error := "Username already taken"

login (username: String, password: String): (sessionToken: String)
**requires**
exists User u where u.username = username and u.hashedPassword = hash(password)
**effects**
let user\_found be the User u where u.username = username
create new unique sessionToken called newSessionToken
add {user: user\_found, sessionToken: newSessionToken} to activeSessions
return sessionToken := newSessionToken

login (username: String, password: String): (error: String)
**requires** not (exists User u where u.username = username and u.hashedPassword = hash(password))
**effects** return error := "Invalid username or password"

logout (sessionToken: String): (success: Boolean)
**requires** exists s in activeSessions where s.sessionToken = sessionToken
**effects**
remove s from activeSessions where s.sessionToken = sessionToken
return success := true

logout (sessionToken: String): (error: String)
**requires** not (exists s in activeSessions where s.sessionToken = sessionToken)
**effects** return error := "Invalid session token"

getCurrentUser (sessionToken: String): (user: User)
**requires** exists s in activeSessions where s.sessionToken = sessionToken
**effects**
let user\_found be s.user where s.sessionToken = sessionToken
return user := user\_found

getCurrentUser (sessionToken: String): (error: String)
**requires** not (exists s in activeSessions where s.sessionToken = sessionToken)
**effects** return error := "Invalid session token"

storeCredential (sessionToken: String, credentialType: String, credentialValue: String): (success: Boolean)
**requires**
exists s in activeSessions where s.sessionToken = sessionToken
credentialType is not an empty string
**effects**
let user\_found be s.user where s.sessionToken = sessionToken
user\_found.additionalCredentials\[credentialType] := credentialValue // In a real system, credentialValue would be encrypted
return success := true

storeCredential (sessionToken: String, credentialType: String, credentialValue: String): (error: String)
**requires** not (exists s in activeSessions where s.sessionToken = sessionToken)
**effects** return error := "Invalid session token"

storeCredential (sessionToken: String, credentialType: String, credentialValue: String): (error: String)
**requires** exists s in activeSessions where s.sessionToken = sessionToken AND credentialType is an empty string
**effects** return error := "Credential type cannot be empty"

retrieveCredential (sessionToken: String, credentialType: String): (credentialValue: String)
**requires**
exists s in activeSessions where s.sessionToken = sessionToken and
let user\_found be s.user where s.sessionToken = sessionToken and
user\_found.additionalCredentials contains key credentialType
**effects**
let user\_found be s.user where s.sessionToken = sessionToken
return credentialValue := user\_found.additionalCredentials\[credentialType]

retrieveCredential (sessionToken: String, credentialType: String): (error: String)
**requires**
not (exists s in activeSessions where s.sessionToken = sessionToken) OR
(exists s in activeSessions where s.sessionToken = sessionToken and
let user\_found be s.user where s.sessionToken = sessionToken and
not (user\_found.additionalCredentials contains key credentialType))
**effects** return error := "Invalid session token or credential type not found"

updateCredential (sessionToken: String, credentialType: String, newCredentialValue: String): (success: Boolean)
**requires**
exists s in activeSessions where s.sessionToken = sessionToken
credentialType is not an empty string
**effects**
let user\_found be s.user where s.sessionToken = sessionToken
user\_found.additionalCredentials\[credentialType] := newCredentialValue
return success := true

updateCredential (sessionToken: String, credentialType: String, newCredentialValue: String): (error: String)
**requires** not (exists s in activeSessions where s.sessionToken = sessionToken)
**effects** return error := "Invalid session token"

updateCredential (sessionToken: String, credentialType: String, newCredentialValue: String): (error: String)
**requires** exists s in activeSessions where s.sessionToken = sessionToken AND credentialType is an empty string
**effects** return error := "Credential type cannot be empty"

updateCredential (sessionToken: String, credentialType: String, newCredentialValue: String): (error: String)
**requires** exists s in activeSessions where s.sessionToken = sessionToken AND (let user\_found be s.user where s.sessionToken = sessionToken AND not (user\_found.additionalCredentials contains key credentialType))
**effects** return error := "Credential type not found for this user"

deleteCredential (sessionToken: String, credentialType: String): (success: Boolean)
**requires**
exists s in activeSessions where s.sessionToken = sessionToken and
let user\_found be s.user where s.sessionToken = sessionToken and
user\_found.additionalCredentials contains key credentialType
**effects**
let user\_found be s.user where s.sessionToken = sessionToken
remove credentialType from user\_found.additionalCredentials
return success := true

deleteCredential (sessionToken: String, credentialType: String): (error: String)
**requires**
not (exists s in activeSessions where s.sessionToken = sessionToken) OR
(exists s in activeSessions where s.sessionToken = sessionToken and
let user\_found be s.user where s.sessionToken = sessionToken and
not (user\_found.additionalCredentials contains key credentialType))
**effects** return error := "Invalid session token or credential type not found"

getCredentialTypes (sessionToken: String): (types: set of String)
**requires** exists s in activeSessions where s.sessionToken = sessionToken
**effects**
let user\_found be s.user where s.sessionToken = sessionToken
return types := keys of user\_found.additionalCredentials

getCredentialTypes (sessionToken: String): (error: String)
**requires** not (exists s in activeSessions where s.sessionToken = sessionToken)
**effects** return error := "Invalid session token"
