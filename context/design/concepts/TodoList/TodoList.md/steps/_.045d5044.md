---
timestamp: 'Thu Oct 23 2025 18:02:09 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251023_180209.6edc2c95.md]]'
content_id: 045d50447ff2f5c46d650627db1eb3a35213de58b78eed3f842408734eec6f40
---

# TodoList

**concept** TodoList \[User, Item]

**purpose** Enable users to organize items into named, time-scoped collections with automatic lifecycle management including clearing completed items and recurring list recreation

**principle** If a user creates a named list with a time range and adds several items to it, they can later retrieve that list by its name and see all the items they added. Items can only be added if they fall within the list's time scope. Lists can automatically clear completed items at the end of their time period, and recurring lists automatically recreate themselves for the next time period.

**state**
a set of Lists with
name: String
owner: User
items: set of Item
startTime: Time // Always present; defaults to MIN\_DATE (Unix epoch) if not specified
endTime: Time // Always present; defaults to MAX\_DATE (Dec 31, 9999) if not specified
autoClearCompleted: Boolean // Whether to auto-clear completed items
recurrenceType: RecurrenceType // none, daily, weekly, monthly

RecurrenceType = none | daily | weekly | monthly

MIN\_DATE = January 1, 1970 00:00:00 UTC (Unix epoch)
MAX\_DATE = December 31, 9999 23:59:59.999 UTC

invariants
each list name is unique per owner
startTime must be before or equal to endTime
if recurrenceType is not none, both startTime and endTime must be explicitly provided (not defaults)

**actions**

createList (owner: User, name: String, startTime: Time?, endTime: Time?, autoClearCompleted: Boolean, recurrenceType: RecurrenceType): (list: List)
**requires**
name is non-empty
for all existing L in Lists, if L.owner == owner then L.name != name
if both startTime and endTime are provided, startTime <= endTime
if recurrenceType is not none, both startTime and endTime must be provided
**effects**
A new list is created with the provided name, owner, and settings. If time boundaries are not provided, startTime defaults to MIN\_DATE and endTime defaults to MAX\_DATE (making the list always active). If time boundaries are provided, the list is scoped to that time range. The autoClearCompleted flag determines whether completed items are automatically cleared. The recurrenceType determines if and how the list recreates itself. The list starts with an empty set of items and is returned.

addListItem (list: List, item: Item, itemDueDate: Time?)
**requires**
list exists
item is not already in list.items
if list has startTime and itemDueDate is provided, itemDueDate >= list.startTime
if list has endTime and itemDueDate is provided, itemDueDate <= list.endTime
**effects**
The item is added to the list's set of items. If the list has time constraints and the item has a due date, the item is only added if it falls within the list's time range.

removeListItem (list: List, item: Item)
**requires** list exists AND item is in list.items
**effects**
The item is removed from the list's set of items.

markItemCompleted (list: List, item: Item, completed: Boolean)
**requires** list exists AND item is in list.items
**effects**
The completion status of the item in the list is updated to the provided value.

deleteList (list: List)
**requires** list exists
**effects**
The list is removed from the set of all lists.

clearCompletedItems (list: List)
**requires** list exists
**effects**
All items in the list where itemCompleted is true are removed from the list's items set.

updateListSettings (list: List, autoClearCompleted: Boolean?, recurrenceType: RecurrenceType?)
**requires**
list exists
if recurrenceType is provided and is not none, list must have both startTime and endTime
**effects**
If autoClearCompleted is provided, the list's autoClearCompleted flag is updated. If recurrenceType is provided, the list's recurrenceType is updated.

**error actions**

createList (owner: User, name: String, startTime: Time?, endTime: Time?, autoClearCompleted: Boolean, recurrenceType: RecurrenceType): (error: String)
**requires** name is empty OR exists L in Lists such that L.owner == owner and L.name == name OR (startTime and endTime provided and startTime > endTime) OR (recurrenceType is not none and startTime or endTime is missing)
**effects** returns error message describing the violation

addListItem (list: List, item: Item, itemDueDate: Time?): (error: String)
**requires** list does not exist OR item is already in list.items OR (list has time constraints and itemDueDate is outside the list's time range)
**effects** returns error message describing the violation

removeListItem (list: List, item: Item): (error: String)
**requires** list does not exist OR item is not in list.items
**effects** returns error message describing the violation

markItemCompleted (list: List, item: Item, completed: Boolean): (error: String)
**requires** list does not exist OR item is not in list.items
**effects** returns error message describing the violation

deleteList (list: List): (error: String)
**requires** list does not exist
**effects** returns error message "List with ID '...' not found."

clearCompletedItems (list: List): (error: String)
**requires** list does not exist
**effects** returns error message "List with ID '...' not found."

updateListSettings (list: List, autoClearCompleted: Boolean?, recurrenceType: RecurrenceType?): (error: String)
**requires** list does not exist OR (recurrenceType is provided and is not none and list does not have both startTime and endTime)
**effects** returns error message describing the violation

**system actions**

autoClearIfNeeded (list: List)
**requires**
list exists
list.autoClearCompleted is true
current time is after list.endTime
**effects**
Removes all items in the list where itemCompleted is true.

recreateRecurringList (list: List)
**requires**
list exists
list.recurrenceType is not none
current time is after list.endTime
**effects**
A new list is created with the same name, owner, autoClearCompleted, and recurrenceType settings. The new list's time range is calculated based on the recurrenceType while maintaining the original list's duration:
\- daily: new startTime is list.endTime + 1 day, new endTime is newStartTime + original duration
\- weekly: new startTime is list.endTime + 1 week, new endTime is newStartTime + original duration
\- monthly: new startTime is list.endTime + 1 month, new endTime is newStartTime + original duration

```
Where original duration = list.endTime - list.startTime.

All uncompleted items from the old list are carried over to the new list with their due dates adjusted by the time shift between the old and new list start times. The original list remains unchanged (archived).
```

**queries**

getListsForUser (user: User): (lists: set of List)
**requires** user is valid
**effects**
Returns the set of all lists owned by the specified user.

getListByName (user: User, name: String): (list: List)
**requires** user is valid, name is non-empty, list with name exists for user
**effects**
Returns the list with the specified name owned by the user.

getActiveListsForUser (user: User): (lists: set of List)
**requires** user is valid
**effects**
Returns the set of all lists owned by the user where current time is between startTime and endTime (inclusive). Lists created without explicit time ranges use MIN\_DATE/MAX\_DATE and are always active.

**query errors**

getListByName (user: User, name: String): (error: String)
**requires** name is empty OR list with name does not exist for user
**effects** returns error message describing the violation
