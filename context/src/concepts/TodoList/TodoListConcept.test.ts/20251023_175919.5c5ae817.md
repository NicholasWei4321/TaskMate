---
timestamp: 'Thu Oct 23 2025 17:59:19 GMT-0400 (Eastern Daylight Time)'
content_id: 5c5ae8178025bf6f5a48c4f63b9fd02196befba6805bc4f58cfcbcf7e75fb905
---

# file: src/concepts/TodoList/TodoListConcept.test.ts

```typescript
import { assertEquals, assertExists, assert } from "jsr:@std/assert";
import { testDb } from "@utils/database.ts";
import { ID } from "@utils/types.ts";
import TodoListConcept from "./TodoListConcept.ts";

// Helper function to create unique user IDs for test isolation
let userCounter = 0;
const createTestUser = () => `user:TestUser${++userCounter}` as ID;

// Helper function to create unique item IDs
let itemCounter = 0;
const createTestItem = () => `item:TestItem${++itemCounter}` as ID;

// ============================================================================
// OPERATIONAL PRINCIPLE TEST
// ============================================================================

Deno.test("Operational Principle: Create time-scoped list with auto-clear and recurrence", async () => {
  console.log("\n=== OPERATIONAL PRINCIPLE TEST ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const alice = createTestUser();
  const task1 = createTestItem();
  const task2 = createTestItem();
  const task3 = createTestItem();

  try {
    const listStartTime = new Date(Date.now() - 2 * 24 * 60 * 60 * 1000);
    const listEndTime = new Date(Date.now() - 1 * 24 * 60 * 60 * 1000);

    console.log("1. Creating 'Daily Chores' list (time-scoped, auto-clear, daily recurring)");
    const createResult = await concept.createList({
      owner: alice,
      name: "Daily Chores",
      startTime: listStartTime,
      endTime: listEndTime,
      autoClearCompleted: true,
      recurrenceType: "daily",
    });
    const listId = (createResult as { list: ID }).list;
    assertExists(listId, "List should be created");
    console.log(`  ✅ Created list with ID: ${listId}`);

    console.log("2. Adding items to the list within time scope");
    await concept.addListItem({ list: listId, item: task1, itemDueDate: new Date(listStartTime.getTime() + 1000) });
    await concept.addListItem({ list: listId, item: task2, itemDueDate: new Date(listEndTime.getTime() - 1000) });
    await concept.addListItem({ list: listId, item: task3 });

    let currentList = (await concept.getListByName({ user: alice, name: "Daily Chores" }) as any).list;
    assertEquals(currentList.items.length, 3, "All 3 items should be added");
    console.log(`  ✅ Added 3 items to list`);

    console.log("3. Marking one item as completed");
    await concept.markItemCompleted({ list: listId, item: task1, completed: true });
    currentList = (await concept.getListByName({ user: alice, name: "Daily Chores" }) as any).list;
    assert(currentList.items.find((i: any) => i.id === task1)!.completed, "Task 1 should be completed");
    console.log(`  ✅ Marked task1 as completed`);

    console.log("4. System auto-clears completed items");
    await concept.autoClearIfNeeded({ list: listId });
    currentList = (await concept.getListByName({ user: alice, name: "Daily Chores" }) as any).list;
    assertEquals(currentList.items.length, 2, "Only 2 uncompleted items should remain");
    assert(!currentList.items.some((i: any) => i.id === task1), "Completed task should be cleared");
    console.log(`  ✅ Auto-cleared completed items`);

    console.log("5. System recreates recurring list for next period");
    await concept.recreateRecurringList({ list: listId });
    const allLists = await concept.getListsForUser({ user: alice });
    const newList = allLists.lists.find((l: any) => l.name === "Daily Chores" && l._id !== listId);
    assertExists(newList, "New recurring list should be created");
    assertEquals(newList!.items.length, 2, "Uncompleted items should be carried over");
    console.log(`  ✅ Created new recurring list with carried-over items`);

    console.log("\n=== OPERATIONAL PRINCIPLE TEST PASSED ===");
  } finally {
    await client.close();
  }
});

// ============================================================================
// ACTION TESTS: createList
// ============================================================================

Deno.test("Action: createList - Basic list creation", async () => {
  console.log("\n=== TEST: createList - Basic Creation ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();

  try {
    const result = await concept.createList({
      owner: user,
      name: "My Daily Tasks",
      autoClearCompleted: true,
      recurrenceType: "none",
    });
    assertExists((result as { list: ID }).list, "Should return a list ID");
    const listId = (result as { list: ID }).list;
    console.log(`  ✅ Created list with ID: ${listId}`);

    const retrieved = await concept.getListByName({ user, name: "My Daily Tasks" });
    const list = (retrieved as any).list;
    assertEquals(list._id, listId, "Retrieved list ID should match");
    assertEquals(list.name, "My Daily Tasks", "Retrieved list name should match");
    assertEquals(list.recurrenceType, "none", "Retrieved list recurrenceType should match");
    // Verify default dates are set
    assertExists(list.startTime, "startTime should exist with default MIN_DATE");
    assertExists(list.endTime, "endTime should exist with default MAX_DATE");
    console.log(`  ✅ Verified list properties with default dates`);
  } finally {
    await client.close();
  }
});

Deno.test("Action: createList - With time range", async () => {
  console.log("\n=== TEST: createList - With Time Range ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();

  try {
    const startTime = new Date(Date.now() - 24 * 60 * 60 * 1000);
    const endTime = new Date(Date.now() + 24 * 60 * 60 * 1000);

    const result = await concept.createList({
      owner: user,
      name: "Weekly Goals",
      startTime,
      endTime,
      autoClearCompleted: false,
      recurrenceType: "none",
    });
    const listId = (result as { list: ID }).list;
    console.log(`  ✅ Created time-scoped list`);

    const retrieved = (await concept.getListByName({ user, name: "Weekly Goals" }) as any).list;
    assertEquals(retrieved.startTime.getTime(), startTime.getTime(), "Start time should match");
    assertEquals(retrieved.endTime.getTime(), endTime.getTime(), "End time should match");
    console.log(`  ✅ Verified time scope`);
  } finally {
    await client.close();
  }
});

Deno.test("Action: createList - Duplicate name should fail", async () => {
  console.log("\n=== TEST: createList - Duplicate Name ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();

  try {
    await concept.createList({ owner: user, name: "My List", autoClearCompleted: false, recurrenceType: "none" });
    const result = await concept.createList({ owner: user, name: "My List", autoClearCompleted: false, recurrenceType: "none" });

    assertExists((result as { error: string }).error, "Should return an error");
    assertEquals((result as { error: string }).error, "A list with this name already exists for this user.");
    console.log(`  ✅ Prevented duplicate list name`);
  } finally {
    await client.close();
  }
});

Deno.test("Action: createList - Empty name should fail", async () => {
  console.log("\n=== TEST: createList - Empty Name ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();

  try {
    const result = await concept.createList({ owner: user, name: "", autoClearCompleted: false, recurrenceType: "none" });
    assertExists((result as { error: string }).error, "Should return an error");
    assertEquals((result as { error: string }).error, "List name cannot be empty.");
    console.log(`  ✅ Prevented empty list name`);
  } finally {
    await client.close();
  }
});

Deno.test("Action: createList - Start time after end time should fail", async () => {
  console.log("\n=== TEST: createList - Invalid Time Range ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();

  try {
    const result = await concept.createList({
      owner: user,
      name: "Invalid Time List",
      startTime: new Date(),
      endTime: new Date(Date.now() - 1000),
      autoClearCompleted: false,
      recurrenceType: "none",
    });
    assertExists((result as { error: string }).error, "Should return an error");
    assertEquals((result as { error: string }).error, "Start time cannot be after end time.");
    console.log(`  ✅ Prevented invalid time range`);
  } finally {
    await client.close();
  }
});

Deno.test("Action: createList - Recurring list without time range should fail", async () => {
  console.log("\n=== TEST: createList - Recurring Without Time ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();

  try {
    const result = await concept.createList({
      owner: user,
      name: "Recurring No Time",
      autoClearCompleted: true,
      recurrenceType: "weekly",
    });
    assertExists((result as { error: string }).error, "Should return an error");
    assertEquals((result as { error: string }).error, "For recurring lists, both start time and end time must be provided.");
    console.log(`  ✅ Prevented recurring list without time bounds`);
  } finally {
    await client.close();
  }
});

// ============================================================================
// ACTION TESTS: addListItem
// ============================================================================

Deno.test("Action: addListItem - Successfully add item", async () => {
  console.log("\n=== TEST: addListItem - Success ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();
  const item = createTestItem();

  try {
    const listId = (await concept.createList({
      owner: user,
      name: "Test List",
      startTime: new Date(Date.now() - 3600 * 1000),
      endTime: new Date(Date.now() + 3600 * 1000),
      autoClearCompleted: false,
      recurrenceType: "none",
    }) as { list: ID }).list;

    const result = await concept.addListItem({ list: listId, item, itemDueDate: new Date() });
    assertEquals(result, {}, "Should successfully add item");

    const list = (await concept.getListByName({ user, name: "Test List" }) as any).list;
    assertEquals(list.items.length, 1, "List should have 1 item");
    assertEquals(list.items[0].id, item, "Item should be in list");
    assertEquals(list.items[0].completed, false, "Item should be uncompleted");
    console.log(`  ✅ Added item successfully`);
  } finally {
    await client.close();
  }
});

Deno.test("Action: addListItem - Add item without due date", async () => {
  console.log("\n=== TEST: addListItem - No Due Date ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();
  const item = createTestItem();

  try {
    const listId = (await concept.createList({ owner: user, name: "Test List", autoClearCompleted: false, recurrenceType: "none" }) as { list: ID }).list;
    const result = await concept.addListItem({ list: listId, item });
    assertEquals(result, {}, "Should successfully add item without due date");
    console.log(`  ✅ Added item without due date`);
  } finally {
    await client.close();
  }
});

Deno.test("Action: addListItem - Duplicate item should fail", async () => {
  console.log("\n=== TEST: addListItem - Duplicate Item ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();
  const item = createTestItem();

  try {
    const listId = (await concept.createList({ owner: user, name: "Test List", autoClearCompleted: false, recurrenceType: "none" }) as { list: ID }).list;
    await concept.addListItem({ list: listId, item });
    const result = await concept.addListItem({ list: listId, item });

    assertExists((result as { error: string }).error, "Should return an error");
    assertEquals((result as { error: string }).error, `Item with ID '${item}' already exists in list '${listId}'.`);
    console.log(`  ✅ Prevented duplicate item`);
  } finally {
    await client.close();
  }
});

Deno.test("Action: addListItem - Item due date before list start should fail", async () => {
  console.log("\n=== TEST: addListItem - Due Date Before Start ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();
  const item = createTestItem();

  try {
    const listId = (await concept.createList({
      owner: user,
      name: "Test List",
      startTime: new Date(Date.now() - 3600 * 1000),
      endTime: new Date(Date.now() + 3600 * 1000),
      autoClearCompleted: false,
      recurrenceType: "none",
    }) as { list: ID }).list;

    const result = await concept.addListItem({ list: listId, item, itemDueDate: new Date(Date.now() - 2 * 3600 * 1000) });
    assertExists((result as { error: string }).error, "Should return an error");
    assert((result as { error: string }).error.includes("is before the list's start time"));
    console.log(`  ✅ Prevented item with due date before start`);
  } finally {
    await client.close();
  }
});

Deno.test("Action: addListItem - Item due date after list end should fail", async () => {
  console.log("\n=== TEST: addListItem - Due Date After End ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();
  const item = createTestItem();

  try {
    const listId = (await concept.createList({
      owner: user,
      name: "Test List",
      startTime: new Date(Date.now() - 3600 * 1000),
      endTime: new Date(Date.now() + 3600 * 1000),
      autoClearCompleted: false,
      recurrenceType: "none",
    }) as { list: ID }).list;

    const result = await concept.addListItem({ list: listId, item, itemDueDate: new Date(Date.now() + 2 * 3600 * 1000) });
    assertExists((result as { error: string }).error, "Should return an error");
    assert((result as { error: string }).error.includes("is after the list's end time"));
    console.log(`  ✅ Prevented item with due date after end`);
  } finally {
    await client.close();
  }
});

Deno.test("Action: addListItem - List not found should fail", async () => {
  console.log("\n=== TEST: addListItem - List Not Found ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const item = createTestItem();

  try {
    const result = await concept.addListItem({ list: "nonExistentList" as ID, item });
    assertExists((result as { error: string }).error, "Should return an error");
    assertEquals((result as { error: string }).error, "List with ID 'nonExistentList' not found.");
    console.log(`  ✅ Prevented adding to non-existent list`);
  } finally {
    await client.close();
  }
});

// ============================================================================
// ACTION TESTS: removeListItem
// ============================================================================

Deno.test("Action: removeListItem - Successfully remove item", async () => {
  console.log("\n=== TEST: removeListItem - Success ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();
  const item1 = createTestItem();
  const item2 = createTestItem();

  try {
    const listId = (await concept.createList({ owner: user, name: "Test List", autoClearCompleted: false, recurrenceType: "none" }) as { list: ID }).list;
    await concept.addListItem({ list: listId, item: item1 });
    await concept.addListItem({ list: listId, item: item2 });

    const result = await concept.removeListItem({ list: listId, item: item1 });
    assertEquals(result, {}, "Should successfully remove item");

    const list = (await concept.getListByName({ user, name: "Test List" }) as any).list;
    assertEquals(list.items.length, 1, "List should have 1 item");
    assertEquals(list.items[0].id, item2, "Only item2 should remain");
    console.log(`  ✅ Removed item successfully`);
  } finally {
    await client.close();
  }
});

Deno.test("Action: removeListItem - Item not in list should fail", async () => {
  console.log("\n=== TEST: removeListItem - Item Not Found ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();
  const item = createTestItem();

  try {
    const listId = (await concept.createList({ owner: user, name: "Test List", autoClearCompleted: false, recurrenceType: "none" }) as { list: ID }).list;
    const result = await concept.removeListItem({ list: listId, item });

    assertExists((result as { error: string }).error, "Should return an error");
    assertEquals((result as { error: string }).error, `Item with ID '${item}' not found in list '${listId}'.`);
    console.log(`  ✅ Prevented removing non-existent item`);
  } finally {
    await client.close();
  }
});

// ============================================================================
// ACTION TESTS: markItemCompleted
// ============================================================================

Deno.test("Action: markItemCompleted - Mark as completed and uncompleted", async () => {
  console.log("\n=== TEST: markItemCompleted - Toggle Completion ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();
  const item = createTestItem();

  try {
    const listId = (await concept.createList({ owner: user, name: "Test List", autoClearCompleted: false, recurrenceType: "none" }) as { list: ID }).list;
    await concept.addListItem({ list: listId, item });

    await concept.markItemCompleted({ list: listId, item, completed: true });
    let list = (await concept.getListByName({ user, name: "Test List" }) as any).list;
    assertEquals(list.items[0].completed, true, "Item should be completed");
    console.log(`  ✅ Marked item as completed`);

    await concept.markItemCompleted({ list: listId, item, completed: false });
    list = (await concept.getListByName({ user, name: "Test List" }) as any).list;
    assertEquals(list.items[0].completed, false, "Item should be uncompleted");
    console.log(`  ✅ Marked item as uncompleted`);
  } finally {
    await client.close();
  }
});

Deno.test("Action: markItemCompleted - Item not in list should fail", async () => {
  console.log("\n=== TEST: markItemCompleted - Item Not Found ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();
  const item = createTestItem();

  try {
    const listId = (await concept.createList({ owner: user, name: "Test List", autoClearCompleted: false, recurrenceType: "none" }) as { list: ID }).list;
    const result = await concept.markItemCompleted({ list: listId, item, completed: true });

    assertExists((result as { error: string }).error, "Should return an error");
    assertEquals((result as { error: string }).error, `Item with ID '${item}' not found in list '${listId}'.`);
    console.log(`  ✅ Prevented marking non-existent item`);
  } finally {
    await client.close();
  }
});

// ============================================================================
// ACTION TESTS: deleteList
// ============================================================================

Deno.test("Action: deleteList - Successfully delete list", async () => {
  console.log("\n=== TEST: deleteList - Success ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();

  try {
    const listId = (await concept.createList({ owner: user, name: "Delete Me", autoClearCompleted: false, recurrenceType: "none" }) as { list: ID }).list;

    const result = await concept.deleteList({ list: listId });
    assertEquals(result, {}, "Should successfully delete list");

    const retrieved = await concept.getListByName({ user, name: "Delete Me" });
    assertExists((retrieved as { error: string }).error, "List should not be found after deletion");
    console.log(`  ✅ Deleted list successfully`);
  } finally {
    await client.close();
  }
});

Deno.test("Action: deleteList - Non-existent list should fail", async () => {
  console.log("\n=== TEST: deleteList - Not Found ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);

  try {
    const result = await concept.deleteList({ list: "nonExistent" as ID });
    assertExists((result as { error: string }).error, "Should return an error");
    assertEquals((result as { error: string }).error, "List with ID 'nonExistent' not found.");
    console.log(`  ✅ Prevented deleting non-existent list`);
  } finally {
    await client.close();
  }
});

// ============================================================================
// ACTION TESTS: clearCompletedItems
// ============================================================================

Deno.test("Action: clearCompletedItems - Clear mixed completed/uncompleted items", async () => {
  console.log("\n=== TEST: clearCompletedItems - Mixed Items ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();
  const item1 = createTestItem();
  const item2 = createTestItem();
  const item3 = createTestItem();

  try {
    const listId = (await concept.createList({ owner: user, name: "Test List", autoClearCompleted: false, recurrenceType: "none" }) as { list: ID }).list;
    await concept.addListItem({ list: listId, item: item1 });
    await concept.addListItem({ list: listId, item: item2 });
    await concept.addListItem({ list: listId, item: item3 });
    await concept.markItemCompleted({ list: listId, item: item1, completed: true });
    await concept.markItemCompleted({ list: listId, item: item3, completed: true });

    const result = await concept.clearCompletedItems({ list: listId });
    assertEquals(result, {}, "Should successfully clear completed items");

    const list = (await concept.getListByName({ user, name: "Test List" }) as any).list;
    assertEquals(list.items.length, 1, "Only 1 uncompleted item should remain");
    assertEquals(list.items[0].id, item2, "Only item2 should remain");
    console.log(`  ✅ Cleared completed items`);
  } finally {
    await client.close();
  }
});

Deno.test("Action: clearCompletedItems - All items completed", async () => {
  console.log("\n=== TEST: clearCompletedItems - All Completed ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();
  const item1 = createTestItem();
  const item2 = createTestItem();

  try {
    const listId = (await concept.createList({ owner: user, name: "Test List", autoClearCompleted: false, recurrenceType: "none" }) as { list: ID }).list;
    await concept.addListItem({ list: listId, item: item1 });
    await concept.addListItem({ list: listId, item: item2 });
    await concept.markItemCompleted({ list: listId, item: item1, completed: true });
    await concept.markItemCompleted({ list: listId, item: item2, completed: true });

    await concept.clearCompletedItems({ list: listId });

    const list = (await concept.getListByName({ user, name: "Test List" }) as any).list;
    assertEquals(list.items.length, 0, "List should be empty");
    console.log(`  ✅ Cleared all items when all completed`);
  } finally {
    await client.close();
  }
});

Deno.test("Action: clearCompletedItems - No items completed (harmless)", async () => {
  console.log("\n=== TEST: clearCompletedItems - None Completed ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();
  const item1 = createTestItem();

  try {
    const listId = (await concept.createList({ owner: user, name: "Test List", autoClearCompleted: false, recurrenceType: "none" }) as { list: ID }).list;
    await concept.addListItem({ list: listId, item: item1 });

    await concept.clearCompletedItems({ list: listId });

    const list = (await concept.getListByName({ user, name: "Test List" }) as any).list;
    assertEquals(list.items.length, 1, "Item should remain");
    console.log(`  ✅ No change when no items completed (harmless operation)`);
  } finally {
    await client.close();
  }
});

// ============================================================================
// ACTION TESTS: updateListSettings
// ============================================================================

Deno.test("Action: updateListSettings - Update autoClearCompleted", async () => {
  console.log("\n=== TEST: updateListSettings - Update autoClearCompleted ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();

  try {
    const listId = (await concept.createList({
      owner: user,
      name: "Test List",
      startTime: new Date(),
      endTime: new Date(Date.now() + 3600 * 1000),
      autoClearCompleted: false,
      recurrenceType: "none",
    }) as { list: ID }).list;

    await concept.updateListSettings({ list: listId, autoClearCompleted: true });

    const list = (await concept.getListByName({ user, name: "Test List" }) as any).list;
    assertEquals(list.autoClearCompleted, true, "autoClearCompleted should be true");
    console.log(`  ✅ Updated autoClearCompleted`);
  } finally {
    await client.close();
  }
});

Deno.test("Action: updateListSettings - Update recurrenceType", async () => {
  console.log("\n=== TEST: updateListSettings - Update recurrenceType ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();

  try {
    const listId = (await concept.createList({
      owner: user,
      name: "Test List",
      startTime: new Date(),
      endTime: new Date(Date.now() + 3600 * 1000),
      autoClearCompleted: false,
      recurrenceType: "none",
    }) as { list: ID }).list;

    await concept.updateListSettings({ list: listId, recurrenceType: "weekly" });

    const list = (await concept.getListByName({ user, name: "Test List" }) as any).list;
    assertEquals(list.recurrenceType, "weekly", "recurrenceType should be weekly");
    console.log(`  ✅ Updated recurrenceType`);
  } finally {
    await client.close();
  }
});

Deno.test("Action: updateListSettings - Update both settings at once", async () => {
  console.log("\n=== TEST: updateListSettings - Update Both ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();

  try {
    const listId = (await concept.createList({
      owner: user,
      name: "Test List",
      startTime: new Date(),
      endTime: new Date(Date.now() + 3600 * 1000),
      autoClearCompleted: false,
      recurrenceType: "none",
    }) as { list: ID }).list;

    await concept.updateListSettings({ list: listId, autoClearCompleted: true, recurrenceType: "daily" });

    const list = (await concept.getListByName({ user, name: "Test List" }) as any).list;
    assertEquals(list.autoClearCompleted, true, "autoClearCompleted should be true");
    assertEquals(list.recurrenceType, "daily", "recurrenceType should be daily");
    console.log(`  ✅ Updated both settings simultaneously`);
  } finally {
    await client.close();
  }
});

Deno.test("Action: updateListSettings - Recurring without time bounds should fail", async () => {
  console.log("\n=== TEST: updateListSettings - Recurring Without Time ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();

  try {
    const listId = (await concept.createList({ owner: user, name: "Test List", autoClearCompleted: false, recurrenceType: "none" }) as { list: ID }).list;
    const result = await concept.updateListSettings({ list: listId, recurrenceType: "daily" });

    assertExists((result as { error: string }).error, "Should return an error");
    assertEquals((result as { error: string }).error, "For recurring lists, both start time and end time must be set if recurrenceType is not 'none'.");
    console.log(`  ✅ Prevented setting recurrence without time bounds`);
  } finally {
    await client.close();
  }
});

// ============================================================================
// SYSTEM ACTION TESTS: autoClearIfNeeded
// ============================================================================

Deno.test("System Action: autoClearIfNeeded - Precondition met, clears items", async () => {
  console.log("\n=== TEST: autoClearIfNeeded - Clears Items ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();
  const item1 = createTestItem();
  const item2 = createTestItem();

  try {
    const listId = (await concept.createList({
      owner: user,
      name: "Test List",
      startTime: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000),
      endTime: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000),
      autoClearCompleted: true,
      recurrenceType: "none",
    }) as { list: ID }).list;
    await concept.addListItem({ list: listId, item: item1 });
    await concept.addListItem({ list: listId, item: item2 });
    await concept.markItemCompleted({ list: listId, item: item1, completed: true });

    const result = await concept.autoClearIfNeeded({ list: listId });
    assertEquals(result, {}, "Should successfully run autoClearIfNeeded");

    const list = (await concept.getListByName({ user, name: "Test List" }) as any).list;
    assertEquals(list.items.length, 1, "Only uncompleted item should remain");
    assertEquals(list.items[0].id, item2, "Item2 should remain");
    console.log(`  ✅ Auto-cleared completed items`);
  } finally {
    await client.close();
  }
});

Deno.test("System Action: autoClearIfNeeded - autoClearCompleted false, no action", async () => {
  console.log("\n=== TEST: autoClearIfNeeded - Flag False ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();
  const item = createTestItem();

  try {
    const listId = (await concept.createList({
      owner: user,
      name: "Test List",
      startTime: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000),
      endTime: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000),
      autoClearCompleted: false,
      recurrenceType: "none",
    }) as { list: ID }).list;
    await concept.addListItem({ list: listId, item });
    await concept.markItemCompleted({ list: listId, item, completed: true });

    const result = await concept.autoClearIfNeeded({ list: listId });
    assertEquals(result, {}, "Should return empty success");

    const list = (await concept.getListByName({ user, name: "Test List" }) as any).list;
    assertEquals(list.items.length, 1, "Item should still be present");
    console.log(`  ✅ No action when autoClearCompleted is false`);
  } finally {
    await client.close();
  }
});

Deno.test("System Action: autoClearIfNeeded - End time in future, no action", async () => {
  console.log("\n=== TEST: autoClearIfNeeded - Future End Time ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();
  const item = createTestItem();

  try {
    const listId = (await concept.createList({
      owner: user,
      name: "Test List",
      startTime: new Date(),
      endTime: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000),
      autoClearCompleted: true,
      recurrenceType: "none",
    }) as { list: ID }).list;
    await concept.addListItem({ list: listId, item });
    await concept.markItemCompleted({ list: listId, item, completed: true });

    const result = await concept.autoClearIfNeeded({ list: listId });
    assertEquals(result, {}, "Should return empty success");

    const list = (await concept.getListByName({ user, name: "Test List" }) as any).list;
    assertEquals(list.items.length, 1, "Item should still be present");
    console.log(`  ✅ No action when end time in future`);
  } finally {
    await client.close();
  }
});

// ============================================================================
// SYSTEM ACTION TESTS: recreateRecurringList
// ============================================================================

Deno.test("System Action: recreateRecurringList - Daily recurrence", async () => {
  console.log("\n=== TEST: recreateRecurringList - Daily ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();
  const item1 = createTestItem();
  const item2 = createTestItem();

  try {
    const originalStart = new Date(Date.now() - 3 * 24 * 60 * 60 * 1000);
    const originalEnd = new Date(Date.now() - 2 * 24 * 60 * 60 * 1000);
    const duration = originalEnd.getTime() - originalStart.getTime();

    const listId = (await concept.createList({
      owner: user,
      name: "Daily List",
      startTime: originalStart,
      endTime: originalEnd,
      autoClearCompleted: true,
      recurrenceType: "daily",
    }) as { list: ID }).list;
    await concept.addListItem({ list: listId, item: item1 });
    await concept.addListItem({ list: listId, item: item2 });
    await concept.markItemCompleted({ list: listId, item: item2, completed: true });

    const result = await concept.recreateRecurringList({ list: listId });
    assertEquals(result, {}, "Should successfully recreate list");

    const allLists = await concept.getListsForUser({ user });
    const newList = allLists.lists.find(l => l.name === "Daily List" && l._id !== listId);
    assertExists(newList, "New list should be created");

    const expectedNewStart = new Date(originalEnd.getTime() + 24 * 60 * 60 * 1000);
    const expectedNewEnd = new Date(expectedNewStart.getTime() + duration);

    assertEquals(newList!.startTime!.getTime(), expectedNewStart.getTime(), "Start time should be 1 day after old end");
    assertEquals(newList!.endTime!.getTime(), expectedNewEnd.getTime(), "End time should maintain duration");
    assertEquals(newList!.items.length, 1, "Only uncompleted item should be carried over");
    assert(newList!.items.some(i => i.id === item1), "Item1 should be carried over");
    assert(!newList!.items.some(i => i.id === item2), "Completed item2 should not be carried over");
    console.log(`  ✅ Daily recurring list created with correct duration`);
  } finally {
    await client.close();
  }
});

Deno.test("System Action: recreateRecurringList - Weekly recurrence", async () => {
  console.log("\n=== TEST: recreateRecurringList - Weekly ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();

  try {
    const originalStart = new Date(Date.now() - 10 * 24 * 60 * 60 * 1000);
    const originalEnd = new Date(Date.now() - 3 * 24 * 60 * 60 * 1000);
    const duration = originalEnd.getTime() - originalStart.getTime();

    const listId = (await concept.createList({
      owner: user,
      name: "Weekly List",
      startTime: originalStart,
      endTime: originalEnd,
      autoClearCompleted: false,
      recurrenceType: "weekly",
    }) as { list: ID }).list;

    await concept.recreateRecurringList({ list: listId });

    const allLists = await concept.getListsForUser({ user });
    const newList = allLists.lists.find(l => l.name === "Weekly List" && l._id !== listId);
    assertExists(newList, "New weekly list should be created");

    const expectedNewStart = new Date(originalEnd.getTime() + 7 * 24 * 60 * 60 * 1000);
    const expectedNewEnd = new Date(expectedNewStart.getTime() + duration);

    assertEquals(newList!.startTime!.getTime(), expectedNewStart.getTime(), "Start time should be 1 week after old end");
    assertEquals(newList!.endTime!.getTime(), expectedNewEnd.getTime(), "End time should maintain duration");
    assertEquals(newList!.recurrenceType, "weekly", "Should maintain weekly recurrence");
    console.log(`  ✅ Weekly recurring list created with correct duration`);
  } finally {
    await client.close();
  }
});

Deno.test("System Action: recreateRecurringList - Monthly recurrence", async () => {
  console.log("\n=== TEST: recreateRecurringList - Monthly ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();

  try {
    const originalStart = new Date(Date.now() - 40 * 24 * 60 * 60 * 1000);
    const originalEnd = new Date(Date.now() - 10 * 24 * 60 * 60 * 1000);
    const duration = originalEnd.getTime() - originalStart.getTime();

    const listId = (await concept.createList({
      owner: user,
      name: "Monthly List",
      startTime: originalStart,
      endTime: originalEnd,
      autoClearCompleted: false,
      recurrenceType: "monthly",
    }) as { list: ID }).list;

    await concept.recreateRecurringList({ list: listId });

    const allLists = await concept.getListsForUser({ user });
    const newList = allLists.lists.find(l => l.name === "Monthly List" && l._id !== listId);
    assertExists(newList, "New monthly list should be created");

    // Month addition is more complex, just verify duration is maintained
    const newDuration = newList!.endTime!.getTime() - newList!.startTime!.getTime();
    assertEquals(newDuration, duration, "Duration should be maintained for monthly recurrence");
    assertEquals(newList!.recurrenceType, "monthly", "Should maintain monthly recurrence");
    console.log(`  ✅ Monthly recurring list created with correct duration`);
  } finally {
    await client.close();
  }
});

Deno.test("System Action: recreateRecurringList - recurrenceType none, no action", async () => {
  console.log("\n=== TEST: recreateRecurringList - None Type ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();

  try {
    const listId = (await concept.createList({
      owner: user,
      name: "Non-Recurring",
      startTime: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000),
      endTime: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000),
      autoClearCompleted: false,
      recurrenceType: "none",
    }) as { list: ID }).list;

    const result = await concept.recreateRecurringList({ list: listId });
    assertEquals(result, {}, "Should return empty success");

    const allLists = await concept.getListsForUser({ user });
    assert(!allLists.lists.some(l => l.name === "Non-Recurring" && l._id !== listId), "No new list should be created");
    console.log(`  ✅ No action for non-recurring list`);
  } finally {
    await client.close();
  }
});

Deno.test("System Action: recreateRecurringList - End time in future, no action", async () => {
  console.log("\n=== TEST: recreateRecurringList - Future End ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();

  try {
    const listId = (await concept.createList({
      owner: user,
      name: "Future List",
      startTime: new Date(),
      endTime: new Date(Date.now() + 10 * 60 * 1000),
      autoClearCompleted: true,
      recurrenceType: "daily",
    }) as { list: ID }).list;

    const result = await concept.recreateRecurringList({ list: listId });
    assertEquals(result, {}, "Should return empty success");

    const allLists = await concept.getListsForUser({ user });
    assert(!allLists.lists.some(l => l.name === "Future List" && l._id !== listId), "No new list should be created");
    console.log(`  ✅ No action when end time in future`);
  } finally {
    await client.close();
  }
});

// ============================================================================
// QUERY TESTS
// ============================================================================

Deno.test("Query: getListsForUser - Returns all lists for user", async () => {
  console.log("\n=== TEST: getListsForUser ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();

  try {
    await concept.createList({ owner: user, name: "List 1", autoClearCompleted: false, recurrenceType: "none" });
    await concept.createList({ owner: user, name: "List 2", autoClearCompleted: false, recurrenceType: "none" });
    await concept.createList({ owner: user, name: "List 3", autoClearCompleted: false, recurrenceType: "none" });

    const result = await concept.getListsForUser({ user });
    assertEquals(result.lists.length, 3, "Should return 3 lists");
    assert(result.lists.every(l => l.owner === user), "All lists should belong to user");
    console.log(`  ✅ Retrieved all lists for user`);
  } finally {
    await client.close();
  }
});

Deno.test("Query: getListByName - Returns specific list", async () => {
  console.log("\n=== TEST: getListByName - Success ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();

  try {
    await concept.createList({ owner: user, name: "My Specific List", autoClearCompleted: false, recurrenceType: "none" });

    const result = await concept.getListByName({ user, name: "My Specific List" });
    const list = (result as any).list;
    assertExists(list, "Should find the list");
    assertEquals(list.name, "My Specific List", "List name should match");
    console.log(`  ✅ Retrieved specific list by name`);
  } finally {
    await client.close();
  }
});

Deno.test("Query: getListByName - Non-existent list returns error", async () => {
  console.log("\n=== TEST: getListByName - Not Found ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();

  try {
    const result = await concept.getListByName({ user, name: "Non Existent" });
    assertExists((result as { error: string }).error, "Should return error");
    console.log(`  ✅ Error returned for non-existent list`);
  } finally {
    await client.close();
  }
});

Deno.test("Query: getActiveListsForUser - Returns only active lists", async () => {
  console.log("\n=== TEST: getActiveListsForUser ===");
  const [db, client] = await testDb();
  const concept = new TodoListConcept(db);
  const user = createTestUser();

  try {
    await concept.createList({ owner: user, name: "No Time", autoClearCompleted: false, recurrenceType: "none" });
    await concept.createList({
      owner: user,
      name: "Active",
      startTime: new Date(Date.now() - 10000),
      endTime: new Date(Date.now() + 10000),
      autoClearCompleted: false,
      recurrenceType: "none",
    });
    await concept.createList({
      owner: user,
      name: "Expired",
      startTime: new Date(Date.now() - 20000),
      endTime: new Date(Date.now() - 10000),
      autoClearCompleted: false,
      recurrenceType: "none",
    });
    await concept.createList({
      owner: user,
      name: "Future",
      startTime: new Date(Date.now() + 10000),
      endTime: new Date(Date.now() + 20000),
      autoClearCompleted: false,
      recurrenceType: "none",
    });

    const result = await concept.getActiveListsForUser({ user });
    assertEquals(result.lists.length, 2, "Should return 2 active lists (No Time + Active)");
    assert(result.lists.some(l => l.name === "No Time"), "No Time list should be active");
    assert(result.lists.some(l => l.name === "Active"), "Active list should be active");
    console.log(`  ✅ Retrieved only active lists`);
  } finally {
    await client.close();
  }
});

```
