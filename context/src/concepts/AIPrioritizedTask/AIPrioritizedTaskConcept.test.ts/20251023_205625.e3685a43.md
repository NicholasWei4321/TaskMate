---
timestamp: 'Thu Oct 23 2025 20:56:25 GMT-0400 (Eastern Daylight Time)'
content_id: e3685a43396753a3c9b701b5233ec67b2ae90787a24d884cd66008f4f8adbb8f
---

# file: src/concepts/AIPrioritizedTask/AIPrioritizedTaskConcept.test.ts

```typescript
// src/concepts/AIPrioritizedTaskConcept.test.ts

import { assert, assertEquals, assertNotEquals, assertExists } from "jsr:@std/assert";
import { testDb } from "@utils/database.ts";
import { ID } from "@utils/types.ts";
import AIPrioritizedTaskConcept from "./AIPrioritizedTaskConcept.ts";

// Define test users
const userA: ID = "user:Alice" as ID;
const userB: ID = "user:Bob" as ID;

// Helper functions
const futureDate = (days: number) => {
  const date = new Date();
  date.setDate(date.getDate() + days);
  return date;
};

const pastDate = (daysAgo: number) => {
  const date = new Date();
  date.setDate(date.getDate() - daysAgo);
  return date;
};

// ============================================================================
// OPERATIONAL PRINCIPLE TEST
// ============================================================================

Deno.test("Operational Principle: Create → Update → Prioritize → Complete workflow", async () => {
  console.log("\n=== OPERATIONAL PRINCIPLE TEST ===");
  const [db, client] = await testDb();
  const concept = new AIPrioritizedTaskConcept(db);
  const principleUser: ID = "user:PrincipleTester" as ID;

  try {
    // 1. Create a task with rich description for LLM inference
    console.log("\n1. Creating task with rich description...");
    const task1Result = await concept.createTask({
      owner: principleUser,
      name: "Prepare critical presentation for board meeting",
      description: "This is a very important and complex presentation requiring significant effort and expertise.",
      dueDate: futureDate(3),
    });
    const taskId1 = (task1Result as any).task;
    let task1 = (await concept.getTask({ task: taskId1 }) as any).taskData;
    console.log(`  ✅ Created task: "${task1.name}"`);
    console.log(`     Priority: ${task1.priorityScore}`);
    console.log(`     LLM Attributes: Effort=${task1.inferredEffortHours}, Importance=${task1.inferredImportance}, Difficulty=${task1.inferredDifficulty}`);
    assertNotEquals(task1.priorityScore, 0, "Initial priority should be calculated");

    // 2. Update the task to change due date
    console.log("\n2. Updating task with new due date...");
    await concept.updateTask({
      task: taskId1,
      newDescription: "Updated: Even more critical now with additional requirements.",
      newDueDate: futureDate(1), // Make it more urgent
    });
    task1 = (await concept.getTask({ task: taskId1 }) as any).taskData;
    console.log(`  ✅ Updated task. New priority: ${task1.priorityScore}`);

    // 3. Create an overdue task and mark it overdue
    console.log("\n3. Creating overdue task and marking it...");
    const task2Result = await concept.createTask({
      owner: principleUser,
      name: "Submit overdue expense report",
      description: "Monthly expense report that should have been submitted.",
      dueDate: pastDate(2),
    });
    const taskId2 = (task2Result as any).task;
    await concept.markOverdue({ task: taskId2 });
    const task2 = (await concept.getTask({ task: taskId2 }) as any).taskData;
    console.log(`  ✅ Marked task as overdue. Priority: ${task2.priorityScore}`);
    assertEquals(task2.overdue, true, "Task should be marked overdue");

    // 4. Query prioritized tasks (should show overdue first)
    console.log("\n4. Querying prioritized tasks...");
    const { tasks: prioritizedTasks } = (await concept.getPrioritizedTasks({ owner: principleUser })) as any;
    console.log(`  Retrieved ${prioritizedTasks.length} prioritized tasks:`);
    prioritizedTasks.forEach((t: any) => {
      console.log(`    - ${t.name} (Priority: ${t.priorityScore}, Overdue: ${t.overdue})`);
    });
    assert(prioritizedTasks[0].priorityScore >= prioritizedTasks[1].priorityScore, "Tasks should be sorted by priority");

    // 5. Complete a task
    console.log("\n5. Completing task...");
    await concept.completeTask({ task: taskId1 });
    task1 = (await concept.getTask({ task: taskId1 }) as any).taskData;
    console.log(`  ✅ Completed task: "${task1.name}"`);
    assertEquals(task1.completed, true, "Task should be completed");
    assertEquals(task1.priorityScore, 0, "Completed task priority should be 0");
    assertEquals(task1.inferredEffortHours, null, "AI attributes should be cleared");

    // 6. Verify completed task not in prioritized list
    console.log("\n6. Verifying completed task excluded from prioritized list...");
    const { tasks: finalTasks } = (await concept.getPrioritizedTasks({ owner: principleUser })) as any;
    assertEquals(finalTasks.some((t: any) => t._id === taskId1), false, "Completed task should not appear");
    console.log(`  ✅ Prioritized list now has ${finalTasks.length} tasks (completed task excluded)`);

    console.log("\n=== OPERATIONAL PRINCIPLE TEST PASSED ===");
  } finally {
    await client.close();
  }
});

// ============================================================================
// ACTION TESTS: createTask
// ============================================================================

Deno.test("Action: createTask - Valid task creation with initial priority", async () => {
  console.log("\n=== TEST: createTask - Valid Creation ===");
  const [db, client] = await testDb();
  const concept = new AIPrioritizedTaskConcept(db);

  try {
    const dueDate = futureDate(5);
    const result = await concept.createTask({
      owner: userA,
      name: "Write Project Report",
      description: "Draft the annual project report for Q3, including budget and progress updates.",
      dueDate: dueDate,
    });

    assertExists((result as { task: ID }).task, "Task should be created successfully");
    const taskId = (result as { task: ID }).task;
    console.log(`  ✅ Task created with ID: ${taskId}`);

    const getResult = await concept.getTask({ task: taskId });
    const taskData = (getResult as any).taskData;

    assertEquals(taskData.owner, userA, "Task owner should match");
    assertEquals(taskData.name, "Write Project Report", "Task name should match");
    assertEquals(taskData.completed, false, "Task should not be completed");
    assertEquals(taskData.overdue, false, "Task should not be overdue initially");
    assertNotEquals(taskData.priorityScore, 0, "Priority score should be calculated");
    assertExists(taskData.lastPriorityCalculationTime, "Last priority calculation time should be set");
    console.log(`  ✅ Verified task properties. Priority: ${taskData.priorityScore}`);
    console.log(`     Input: owner=${taskData.owner}, name="${taskData.name}", due=${taskData.dueDate.toISOString()}`);
    console.log(`     Output: completed=${taskData.completed}, overdue=${taskData.overdue}, priority=${taskData.priorityScore}`);
  } finally {
    await client.close();
  }
});

Deno.test("Action: createTask - Duplicate task name should fail", async () => {
  console.log("\n=== TEST: createTask - Duplicate Name ===");
  const [db, client] = await testDb();
  const concept = new AIPrioritizedTaskConcept(db);

  try {
    const dueDate = futureDate(3);
    await concept.createTask({
      owner: userA,
      name: "Review PR",
      description: "Review pull request #123 for feature X.",
      dueDate: dueDate,
    });
    console.log(`  Created first task: "Review PR" for ${userA}`);

    const result = await concept.createTask({
      owner: userA,
      name: "Review PR",
      description: "Review pull request #456 for feature Y.",
      dueDate: dueDate,
    });

    assertExists((result as { error: string }).error, "Creating task with duplicate name should return an error");
    assertEquals((result as { error: string }).error, "Task with name 'Review PR' already exists for this owner.");
    console.log(`  ✅ Correctly prevented duplicate task name for owner ${userA}`);
    console.log(`     Input: owner=${userA}, name="Review PR" (duplicate)`);
    console.log(`     Output: error="${(result as { error: string }).error}"`);
  } finally {
    await client.close();
  }
});

Deno.test("Action: createTask - Empty task name should fail", async () => {
  console.log("\n=== TEST: createTask - Empty Name ===");
  const [db, client] = await testDb();
  const concept = new AIPrioritizedTaskConcept(db);

  try {
    const result = await concept.createTask({
      owner: userA,
      name: "",
      description: "Some description.",
      dueDate: futureDate(1),
    });
    assertExists((result as { error: string }).error, "Creating task with empty name should return an error");
    assertEquals((result as { error: string }).error, "Task name cannot be empty.");
    console.log(`  ✅ Correctly prevented empty task name`);
    console.log(`     Input: name="" (empty)`);
    console.log(`     Output: error="${(result as { error: string }).error}"`);
  } finally {
    await client.close();
  }
});

Deno.test("Action: createTask - Invalid due date should fail", async () => {
  console.log("\n=== TEST: createTask - Invalid Date ===");
  const [db, client] = await testDb();
  const concept = new AIPrioritizedTaskConcept(db);

  try {
    const result = await concept.createTask({
      owner: userA,
      name: "Invalid Date Task",
      description: "This task has an invalid date.",
      dueDate: new Date("not a date"),
    });
    assertExists((result as { error: string }).error, "Creating task with invalid due date should return an error");
    assertEquals((result as { error: string }).error, "Invalid due date. Please provide a valid date/time.");
    console.log(`  ✅ Correctly prevented invalid due date`);
    console.log(`     Input: dueDate=new Date("not a date") (invalid)`);
    console.log(`     Output: error="${(result as { error: string }).error}"`);
  } finally {
    await client.close();
  }
});

// ============================================================================
// ACTION TESTS: updateTask
// ============================================================================

Deno.test("Action: updateTask - Update name, description, and due date", async () => {
  console.log("\n=== TEST: updateTask - Valid Update ===");
  const [db, client] = await testDb();
  const concept = new AIPrioritizedTaskConcept(db);

  try {
    const createResult = await concept.createTask({
      owner: userA,
      name: "Old Task Name",
      description: "Old description.",
      dueDate: futureDate(10),
    });
    const taskId = (createResult as { task: ID }).task;
    console.log(`  Created task ID: ${taskId}`);

    const newDueDate = futureDate(15);
    const updateResult = await concept.updateTask({
      task: taskId,
      newName: "New Updated Task Name",
      newDescription: "Updated description for the task.",
      newDueDate: newDueDate,
    });

    assertExists((updateResult as { task: ID }).task, "Task update should be successful");
    console.log(`  ✅ Task updated successfully`);

    const updatedTask = (await concept.getTask({ task: taskId }) as any).taskData;
    assertEquals(updatedTask.name, "New Updated Task Name", "Task name should be updated");
    assertEquals(updatedTask.description, "Updated description for the task.", "Task description should be updated");
    assertEquals(updatedTask.dueDate.toISOString(), newDueDate.toISOString(), "Task due date should be updated");
    assertEquals(updatedTask.overdue, false, "Overdue flag should be reset after due date update");
    assertNotEquals(updatedTask.priorityScore, 0, "Priority score should be recalculated after update");
    console.log(`  ✅ Verified updated properties. New priority: ${updatedTask.priorityScore}`);
    console.log(`     Input: newName="New Updated Task Name", newDescription="Updated...", newDueDate=${newDueDate.toISOString()}`);
    console.log(`     Output: name="${updatedTask.name}", priority=${updatedTask.priorityScore}`);
  } finally {
    await client.close();
  }
});

Deno.test("Action: updateTask - Update with duplicate name should fail", async () => {
  console.log("\n=== TEST: updateTask - Duplicate Name ===");
  const [db, client] = await testDb();
  const concept = new AIPrioritizedTaskConcept(db);

  try {
    const task1 = (await concept.createTask({ owner: userA, name: "Task One", description: "", dueDate: futureDate(1) }) as any).task;
    await concept.createTask({ owner: userA, name: "Task Two", description: "", dueDate: futureDate(1) });
    console.log(`  Created two tasks: "Task One" and "Task Two"`);

    const result = await concept.updateTask({ task: task1, newName: "Task Two" });
    assertExists((result as { error: string }).error, "Updating to duplicate name should fail");
    assertEquals((result as { error: string }).error, "Task with name 'Task Two' already exists for this owner.");
    console.log(`  ✅ Correctly prevented updating to a duplicate task name`);
    console.log(`     Input: newName="Task Two" (already exists)`);
    console.log(`     Output: error="${(result as { error: string }).error}"`);
  } finally {
    await client.close();
  }
});

Deno.test("Action: updateTask - Update with empty name should fail", async () => {
  console.log("\n=== TEST: updateTask - Empty Name ===");
  const [db, client] = await testDb();
  const concept = new AIPrioritizedTaskConcept(db);

  try {
    const task1 = (await concept.createTask({ owner: userA, name: "Valid Task", description: "", dueDate: futureDate(1) }) as any).task;
    console.log(`  Created task: "Valid Task"`);

    const result = await concept.updateTask({ task: task1, newName: "" });
    assertExists((result as { error: string }).error, "Updating with empty name should fail");
    assertEquals((result as { error: string }).error, "New task name cannot be empty.");
    console.log(`  ✅ Correctly prevented updating to empty name`);
    console.log(`     Input: newName="" (empty)`);
    console.log(`     Output: error="${(result as { error: string }).error}"`);
  } finally {
    await client.close();
  }
});

// ============================================================================
// ACTION TESTS: snoozeTask
// ============================================================================

Deno.test("Action: snoozeTask - Snooze task to future date", async () => {
  console.log("\n=== TEST: snoozeTask - Valid Snooze ===");
  const [db, client] = await testDb();
  const concept = new AIPrioritizedTaskConcept(db);

  try {
    const createResult = await concept.createTask({
      owner: userA,
      name: "Urgent Meeting Prep",
      description: "Prepare slides for the client meeting.",
      dueDate: futureDate(1),
    });
    const taskId = (createResult as { task: ID }).task;
    const originalDueDate = (await concept.getTask({ task: taskId }) as any).taskData.dueDate;
    console.log(`  Created task due: ${originalDueDate.toISOString()}`);

    const newSnoozeDate = futureDate(7);
    const snoozeResult = await concept.snoozeTask({ task: taskId, newDueDate: newSnoozeDate });
    assertExists((snoozeResult as { task: ID }).task, "Snooze should be successful");
    console.log(`  ✅ Task snoozed successfully`);

    const snoozedTask = (await concept.getTask({ task: taskId }) as any).taskData;
    assertEquals(snoozedTask.dueDate.toISOString(), newSnoozeDate.toISOString(), "Task due date should be updated");
    assertEquals(snoozedTask.overdue, false, "Overdue flag should be reset after snoozing");
    assertNotEquals(snoozedTask.priorityScore, 0, "Priority score should be recalculated");
    console.log(`  ✅ Verified snoozed task. New priority: ${snoozedTask.priorityScore}`);
    console.log(`     Input: newDueDate=${newSnoozeDate.toISOString()}`);
    console.log(`     Output: dueDate=${snoozedTask.dueDate.toISOString()}, priority=${snoozedTask.priorityScore}`);
  } finally {
    await client.close();
  }
});

Deno.test("Action: snoozeTask - Snooze to past date should fail", async () => {
  console.log("\n=== TEST: snoozeTask - Past Date ===");
  const [db, client] = await testDb();
  const concept = new AIPrioritizedTaskConcept(db);

  try {
    const taskId = (await concept.createTask({ owner: userA, name: "Task to Snooze", description: "", dueDate: futureDate(1) }) as any).task;
    console.log(`  Created task to snooze`);

    const result = await concept.snoozeTask({ task: taskId, newDueDate: pastDate(1) });
    assertExists((result as { error: string }).error, "Snooze to past date should fail");
    assertEquals((result as { error: string }).error, "New due date must be in the future to snooze a task.");
    console.log(`  ✅ Correctly prevented snoozing to a past date`);
    console.log(`     Input: newDueDate=${pastDate(1).toISOString()} (in the past)`);
    console.log(`     Output: error="${(result as { error: string }).error}"`);
  } finally {
    await client.close();
  }
});

Deno.test("Action: snoozeTask - Snooze to current time should fail", async () => {
  console.log("\n=== TEST: snoozeTask - Current Time ===");
  const [db, client] = await testDb();
  const concept = new AIPrioritizedTaskConcept(db);

  try {
    const taskId = (await concept.createTask({ owner: userA, name: "Another Task", description: "", dueDate: futureDate(1) }) as any).task;
    console.log(`  Created task to snooze`);

    const result = await concept.snoozeTask({ task: taskId, newDueDate: new Date() });
    assertExists((result as { error: string }).error, "Snooze to current time should fail");
    assertEquals((result as { error: string }).error, "New due date must be in the future to snooze a task.");
    console.log(`  ✅ Correctly prevented snoozing to current time`);
    console.log(`     Input: newDueDate=new Date() (current time)`);
    console.log(`     Output: error="${(result as { error: string }).error}"`);
  } finally {
    await client.close();
  }
});

// ============================================================================
// ACTION TESTS: completeTask
// ============================================================================

Deno.test("Action: completeTask - Mark task as completed", async () => {
  console.log("\n=== TEST: completeTask - Mark Completed ===");
  const [db, client] = await testDb();
  const concept = new AIPrioritizedTaskConcept(db);

  try {
    const createResult = await concept.createTask({
      owner: userA,
      name: "Finish book chapter",
      description: "Complete chapter 5 of the technical book.",
      dueDate: futureDate(2),
    });
    const taskId = (createResult as { task: ID }).task;
    console.log(`  Created task ID: ${taskId}`);

    const completeResult = await concept.completeTask({ task: taskId });
    assertExists((completeResult as { task: ID }).task, "Complete task action should be successful");
    console.log(`  ✅ Task completed successfully`);

    const completedTask = (await concept.getTask({ task: taskId }) as any).taskData;
    assertEquals(completedTask.completed, true, "Task should be marked as completed");
    assertEquals(completedTask.priorityScore, 0, "Completed task's priority should be zero");
    assertEquals(completedTask.inferredEffortHours, null, "Inferred effort should be cleared");
    assertEquals(completedTask.inferredImportance, null, "Inferred importance should be cleared");
    assertEquals(completedTask.inferredDifficulty, null, "Inferred difficulty should be cleared");
    assertExists(completedTask.lastPriorityCalculationTime, "Last priority calculation time should be updated");
    console.log(`  ✅ Verified completed task properties`);
    console.log(`     Input: task=${taskId}`);
    console.log(`     Output: completed=${completedTask.completed}, priority=${completedTask.priorityScore}, AI attributes=null`);
  } finally {
    await client.close();
  }
});

// ============================================================================
// SYSTEM ACTION TESTS: markOverdue
// ============================================================================

Deno.test("System Action: markOverdue - Mark overdue task", async () => {
  console.log("\n=== TEST: markOverdue - Mark Overdue ===");
  const [db, client] = await testDb();
  const concept = new AIPrioritizedTaskConcept(db);

  try {
    const createResult = await concept.createTask({
      owner: userB,
      name: "Pay utility bill",
      description: "Monthly utility bill payment.",
      dueDate: pastDate(1),
    });
    const taskId = (createResult as { task: ID }).task;
    const initialTask = (await concept.getTask({ task: taskId }) as any).taskData;
    console.log(`  Created overdue task due: ${initialTask.dueDate.toISOString()}`);
    console.log(`     Initial overdue flag: ${initialTask.overdue}`);
    console.log(`     Initial priority: ${initialTask.priorityScore}`);

    // Verify task is not yet marked overdue
    assertEquals(initialTask.overdue, false, "Task should not be marked overdue initially");

    const markResult = await concept.markOverdue({ task: taskId });
    assertEquals(markResult, {}, "markOverdue should return an empty object on success");
    console.log(`  ✅ markOverdue action executed`);

    const updatedTask = (await concept.getTask({ task: taskId }) as any).taskData;
    assertEquals(updatedTask.overdue, true, "Task should be marked as overdue");
    assertNotEquals(updatedTask.priorityScore, 0, "Priority should be non-zero for overdue task");
    assertExists(updatedTask.lastPriorityCalculationTime, "Last priority calculation time should be updated");
    console.log(`  ✅ Verified task is overdue. Priority: ${updatedTask.priorityScore}`);
    console.log(`     Input: task=${taskId} (past due date)`);
    console.log(`     Output: overdue=true, priority=${updatedTask.priorityScore}`);
  } finally {
    await client.close();
  }
});

Deno.test("System Action: markOverdue - Skip if task is completed", async () => {
  console.log("\n=== TEST: markOverdue - Skip Completed ===");
  const [db, client] = await testDb();
  const concept = new AIPrioritizedTaskConcept(db);

  try {
    const taskId = (await concept.createTask({ owner: userB, name: "Completed Task", description: "", dueDate: pastDate(1) }) as any).task;
    await concept.completeTask({ task: taskId });
    console.log(`  Created and completed task`);

    const result = await concept.markOverdue({ task: taskId });
    assertEquals(result, {}, "markOverdue should return empty object if task is completed");

    const task = (await concept.getTask({ task: taskId }) as any).taskData;
    assertEquals(task.overdue, false, "Completed task should not be marked overdue");
    console.log(`  ✅ Correctly skipped marking overdue for completed task`);
    console.log(`     Input: task=${taskId} (completed)`);
    console.log(`     Output: {} (no action taken), overdue=false`);
  } finally {
    await client.close();
  }
});

Deno.test("System Action: markOverdue - Skip if task not yet due", async () => {
  console.log("\n=== TEST: markOverdue - Skip Future Task ===");
  const [db, client] = await testDb();
  const concept = new AIPrioritizedTaskConcept(db);

  try {
    const taskId = (await concept.createTask({ owner: userB, name: "Future Task", description: "", dueDate: futureDate(5) }) as any).task;
    console.log(`  Created future task`);

    const result = await concept.markOverdue({ task: taskId });
    assertEquals(result, {}, "markOverdue should return empty object if task is not yet due");

    const task = (await concept.getTask({ task: taskId }) as any).taskData;
    assertEquals(task.overdue, false, "Future task should not be marked overdue");
    console.log(`  ✅ Correctly skipped marking overdue for future task`);
    console.log(`     Input: task=${taskId} (future due date)`);
    console.log(`     Output: {} (no action taken), overdue=false`);
  } finally {
    await client.close();
  }
});

// ============================================================================
// SYSTEM ACTION TESTS: calculateTaskPriority
// ============================================================================

Deno.test("System Action: calculateTaskPriority - Recalculate priority", async () => {
  console.log("\n=== TEST: calculateTaskPriority - Recalculate ===");
  const [db, client] = await testDb();
  const concept = new AIPrioritizedTaskConcept(db);

  try {
    const createResult = await concept.createTask({
      owner: userB,
      name: "Review codebase for security vulnerabilities",
      description: "Perform a comprehensive security review of the main backend codebase. High importance.",
      dueDate: futureDate(14),
    });
    const taskId = (createResult as { task: ID }).task;
    const initialTask = (await concept.getTask({ task: taskId }) as any).taskData;
    const initialCalcTime = initialTask.lastPriorityCalculationTime;
    console.log(`  Created task with initial priority: ${initialTask.priorityScore}`);

    // Small delay to ensure timestamp difference
    await new Promise(resolve => setTimeout(resolve, 10));

    const calculateResult = await concept.calculateTaskPriority({ task: taskId });
    assertEquals(calculateResult, {}, "calculateTaskPriority should return an empty object on success");
    console.log(`  ✅ calculateTaskPriority action executed`);

    const updatedTask = (await concept.getTask({ task: taskId }) as any).taskData;
    assertExists(updatedTask.lastPriorityCalculationTime, "Last priority calculation time should be updated");
    assertNotEquals(
      updatedTask.lastPriorityCalculationTime.getTime(),
      initialCalcTime.getTime(),
      "Last priority calculation time should be different"
    );
    console.log(`  ✅ Priority recalculated. Priority: ${updatedTask.priorityScore}`);
    console.log(`     Input: task=${taskId}`);
    console.log(`     Output: priority=${updatedTask.priorityScore}, lastCalcTime updated`);
  } finally {
    await client.close();
  }
});

Deno.test("System Action: calculateTaskPriority - Skip if task completed", async () => {
  console.log("\n=== TEST: calculateTaskPriority - Skip Completed ===");
  const [db, client] = await testDb();
  const concept = new AIPrioritizedTaskConcept(db);

  try {
    const taskId = (await concept.createTask({ owner: userB, name: "Another Completed Task", description: "", dueDate: futureDate(1) }) as any).task;
    await concept.completeTask({ task: taskId });
    console.log(`  Created and completed task`);

    const result = await concept.calculateTaskPriority({ task: taskId });
    assertEquals(result, {}, "calculateTaskPriority should return empty object if task is completed");

    const task = (await concept.getTask({ task: taskId }) as any).taskData;
    assertEquals(task.priorityScore, 0, "Completed task priority should remain 0");
    console.log(`  ✅ Correctly skipped recalculating priority for completed task`);
    console.log(`     Input: task=${taskId} (completed)`);
    console.log(`     Output: {} (no action taken), priority=0`);
  } finally {
    await client.close();
  }
});

// ============================================================================
// QUERY TESTS
// ============================================================================

Deno.test("Query: getTask - Retrieve specific task by ID", async () => {
  console.log("\n=== TEST: getTask - Retrieve by ID ===");
  const [db, client] = await testDb();
  const concept = new AIPrioritizedTaskConcept(db);

  try {
    const createResult = await concept.createTask({
      owner: userA,
      name: "Meeting with Stakeholders",
      description: "Discuss project roadmap and upcoming features.",
      dueDate: futureDate(3),
    });
    const taskId = (createResult as { task: ID }).task;
    console.log(`  Created task ID: ${taskId}`);

    const getResult = await concept.getTask({ task: taskId });
    assertExists((getResult as any).taskData, "Should retrieve task data");
    const taskData = (getResult as any).taskData;

    assertEquals(taskData._id, taskId, "Retrieved task ID should match");
    assertEquals(taskData.name, "Meeting with Stakeholders", "Retrieved task name should match");
    assertEquals(taskData.owner, userA, "Retrieved task owner should match");
    console.log(`  ✅ Retrieved task successfully by ID`);
    console.log(`     Input: task=${taskId}`);
    console.log(`     Output: taskData={_id=${taskData._id}, name="${taskData.name}", owner=${taskData.owner}}`);
  } finally {
    await client.close();
  }
});

Deno.test("Query: getTasksByOwner - Retrieve all tasks sorted by priority", async () => {
  console.log("\n=== TEST: getTasksByOwner - Retrieve and Sort ===");
  const [db, client] = await testDb();
  const concept = new AIPrioritizedTaskConcept(db);
  const queryUser: ID = "user:GetTasksByOwnerTest" as ID;

  try {
    const task1 = (await concept.createTask({ owner: queryUser, name: "High Priority", description: "Important", dueDate: futureDate(1) }) as any).task;
    const task2 = (await concept.createTask({ owner: queryUser, name: "Medium Priority", description: "Moderate", dueDate: futureDate(5) }) as any).task;
    const task3 = (await concept.createTask({ owner: queryUser, name: "Low Priority", description: "Later", dueDate: futureDate(10) }) as any).task;
    console.log(`  Created 3 tasks for ${queryUser}`);

    const { tasks } = (await concept.getTasksByOwner({ owner: queryUser })) as any;
    assertEquals(tasks.length, 3, "Should retrieve all 3 tasks");
    console.log(`  Retrieved ${tasks.length} tasks`);

    // Verify sorting by priority (descending)
    for (let i = 0; i < tasks.length - 1; i++) {
      assert(tasks[i].priorityScore >= tasks[i + 1].priorityScore, "Tasks should be sorted by priority descending");
    }
    console.log(`  ✅ Verified tasks are sorted by priority (descending)`);
    tasks.forEach((t: any) => console.log(`    - ${t.name} (Priority: ${t.priorityScore}, Completed: ${t.completed})`));
    console.log(`     Input: owner=${queryUser}`);
    console.log(`     Output: tasks array with ${tasks.length} items, sorted by priority`);
  } finally {
    await client.close();
  }
});

Deno.test("Query: getPrioritizedTasks - Retrieve only non-completed tasks", async () => {
  console.log("\n=== TEST: getPrioritizedTasks - Filter Completed ===");
  const [db, client] = await testDb();
  const concept = new AIPrioritizedTaskConcept(db);
  const queryUser: ID = "user:GetPrioritizedTasksTest" as ID;

  try {
    const task1 = (await concept.createTask({ owner: queryUser, name: "Active Task 1", description: "Active", dueDate: futureDate(2) }) as any).task;
    const task2 = (await concept.createTask({ owner: queryUser, name: "Active Task 2", description: "Active", dueDate: futureDate(6) }) as any).task;
    const task3 = (await concept.createTask({ owner: queryUser, name: "Completed Task", description: "Done", dueDate: futureDate(3) }) as any).task;
    await concept.completeTask({ task: task3 });
    console.log(`  Created 3 tasks (1 completed) for ${queryUser}`);

    const { tasks } = (await concept.getPrioritizedTasks({ owner: queryUser })) as any;
    assertEquals(tasks.length, 2, "Should retrieve only 2 non-completed tasks");
    console.log(`  Retrieved ${tasks.length} non-completed tasks`);

    // Verify no completed tasks are returned
    tasks.forEach((task: any) => assertEquals(task.completed, false, "Should not return completed tasks"));

    // Verify sorting by priority (descending)
    for (let i = 0; i < tasks.length - 1; i++) {
      assert(tasks[i].priorityScore >= tasks[i + 1].priorityScore, "Tasks should be sorted by priority descending");
    }
    console.log(`  ✅ Verified only non-completed tasks returned and sorted by priority`);
    tasks.forEach((t: any) => console.log(`    - ${t.name} (Priority: ${t.priorityScore}, Completed: ${t.completed})`));
    console.log(`     Input: owner=${queryUser}`);
    console.log(`     Output: tasks array with 2 non-completed items, sorted by priority`);
  } finally {
    await client.close();
  }
});

```
