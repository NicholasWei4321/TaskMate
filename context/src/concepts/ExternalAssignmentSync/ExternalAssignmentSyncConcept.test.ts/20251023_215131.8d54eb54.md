---
timestamp: 'Thu Oct 23 2025 21:51:31 GMT-0400 (Eastern Daylight Time)'
content_id: 8d54eb54c188f2cfc366d704ac881f001a706277bbc978b841bc81d6811ecf36
---

# file: src/concepts/ExternalAssignmentSync/ExternalAssignmentSyncConcept.test.ts

```typescript
// src/concepts/ExternalAssignmentSync/ExternalAssignmentSyncConcept.test.ts
import "jsr:@std/dotenv/load";
import { assertEquals, assertExists, assertNotEquals } from "jsr:@std/assert";
import { testDb, freshID } from "@utils/database.ts";
import type { ID } from "@utils/types.ts";
import ExternalAssignmentSyncConcept from "./ExternalAssignmentSyncConcept.ts";

// Re-declare types for clarity within the test file
type User = ID;
type Assignment = ID;
type ConnectionDetails = {
  apiToken: string;
  baseUrl: string;
};
type ExternalAssignmentDetails = {
  name: string;
  description?: string;
  dueDate?: number;
};
type RawExternalAssignment = {
  externalId: string;
  details: ExternalAssignmentDetails;
  externalModificationTimestamp: number;
};
type AssignmentToProcess = {
  externalId: string;
  details: ExternalAssignmentDetails;
  externalModificationTimestamp: number;
  existingInternalId: Assignment | null;
};
type ExternalSourceAccountDoc = {
  _id: ID;
  owner: User;
  sourceType: string;
  sourceName: string;
  connectionDetails: ConnectionDetails;
  lastSuccessfulPoll?: number;
};
type ExternalAssignmentDoc = {
  _id: ID;
  source: ID;
  externalId: string;
  internalAssignment: Assignment;
  lastExternalModificationTimestamp: number;
};

// Error return types for assertions
type ErrorResult = { error: string };
type ConnectSourceSuccess = { sourceAccount: ID };
type PollExternalSourceSuccess = { rawExternalAssignments: RawExternalAssignment[] };
type IdentifyChangesSuccess = { assignmentsToProcess: AssignmentToProcess[] };
type GetSourcesForUserSuccess = { sources: ExternalSourceAccountDoc[] };
type GetMappedInternalIdSuccess = { internalId: ID };
type GetAssignmentsForSourceSuccess = { assignments: ExternalAssignmentDoc[] };

// Check if Canvas credentials are available
const CANVAS_TOKEN = Deno.env.get("CANVAS_API_TOKEN");
const CANVAS_URL = Deno.env.get("CANVAS_BASE_URL") || "https://canvas.mit.edu";
const SKIP_CANVAS_TESTS = !CANVAS_TOKEN;

if (SKIP_CANVAS_TESTS) {
  console.warn("\n⚠️  CANVAS_API_TOKEN not set - skipping Canvas integration tests\n");
}

Deno.test("ExternalAssignmentSync - connectSource with invalid credentials", async () => {
  const [db, client] = await testDb();
  const concept = new ExternalAssignmentSyncConcept(db);
  const userA: User = freshID();

  try {
    const invalidDetails: ConnectionDetails = {
      apiToken: "invalid_token",
      baseUrl: CANVAS_URL,
    };
    const result = await concept.connectSource({
      owner: userA,
      sourceType: "Canvas",
      sourceName: "Invalid Canvas",
      details: invalidDetails,
    }) as ErrorResult;

    assertExists(result.error, "Should return an error for invalid credentials");
    assertEquals(result.error, "Invalid credentials provided.");
    console.log("✓ Invalid credentials rejected");
  } finally {
    await client.close();
  }
});

Deno.test("ExternalAssignmentSync - connectSource duplicate source name", async () => {
  if (SKIP_CANVAS_TESTS) return;

  const [db, client] = await testDb();
  const concept = new ExternalAssignmentSyncConcept(db);
  const userA: User = freshID();

  try {
    const canvasDetails: ConnectionDetails = {
      apiToken: CANVAS_TOKEN!,
      baseUrl: CANVAS_URL,
    };

    // First connection should succeed
    const result1 = await concept.connectSource({
      owner: userA,
      sourceType: "Canvas",
      sourceName: "My Canvas",
      details: canvasDetails,
    }) as ConnectSourceSuccess;

    assertExists(result1.sourceAccount);
    console.log(`✓ First connection succeeded: ${result1.sourceAccount}`);

    // Second connection with same name should fail
    const result2 = await concept.connectSource({
      owner: userA,
      sourceType: "Canvas",
      sourceName: "My Canvas",
      details: canvasDetails,
    }) as ErrorResult;

    assertExists(result2.error);
    assertEquals(result2.error, "A source with name 'My Canvas' already exists for this user.");
    console.log("✓ Duplicate source name rejected");

    // Cleanup
    await concept.disconnectSource({ sourceAccount: result1.sourceAccount });
  } finally {
    await client.close();
  }
});

Deno.test("ExternalAssignmentSync - connectSource and pollExternalSource with real Canvas", async () => {
  if (SKIP_CANVAS_TESTS) return;

  const [db, client] = await testDb();
  const concept = new ExternalAssignmentSyncConcept(db);
  const userA: User = freshID();

  try {
    const canvasDetails: ConnectionDetails = {
      apiToken: CANVAS_TOKEN!,
      baseUrl: CANVAS_URL,
    };

    // Connect to Canvas
    const connectResult = await concept.connectSource({
      owner: userA,
      sourceType: "Canvas",
      sourceName: "Test Canvas Source",
      details: canvasDetails,
    }) as ConnectSourceSuccess;

    assertExists(connectResult.sourceAccount);
    const sourceId = connectResult.sourceAccount;
    console.log(`✓ Connected to Canvas: ${sourceId}`);

    // Verify source was created
    const sources = await concept._getSourcesForUser({ user: userA }) as GetSourcesForUserSuccess;
    assertEquals(sources.sources.length, 1);
    assertEquals(sources.sources[0]._id, sourceId);
    assertEquals(sources.sources[0].sourceType, "Canvas");
    console.log("✓ Source stored in database");

    // Poll Canvas API
    const pollResult = await concept.pollExternalSource({
      sourceAccount: sourceId,
    }) as PollExternalSourceSuccess;

    assertExists(pollResult.rawExternalAssignments);
    console.log(`✓ Fetched ${pollResult.rawExternalAssignments.length} assignments from Canvas`);

    // Verify assignment structure
    if (pollResult.rawExternalAssignments.length > 0) {
      const firstAssignment = pollResult.rawExternalAssignments[0];
      assertExists(firstAssignment.externalId, "Assignment should have externalId");
      assertExists(firstAssignment.details.name, "Assignment should have name");
      assertExists(firstAssignment.externalModificationTimestamp, "Assignment should have timestamp");
      console.log(`✓ Assignment structure valid: ${firstAssignment.details.name}`);
    }

    // Cleanup
    await concept.disconnectSource({ sourceAccount: sourceId });
    console.log("✓ Cleanup successful");
  } finally {
    await client.close();
  }
});

Deno.test("ExternalAssignmentSync - identifyChanges detects new assignments", async () => {
  if (SKIP_CANVAS_TESTS) return;

  const [db, client] = await testDb();
  const concept = new ExternalAssignmentSyncConcept(db);
  const userA: User = freshID();

  try {
    const canvasDetails: ConnectionDetails = {
      apiToken: CANVAS_TOKEN!,
      baseUrl: CANVAS_URL,
    };

    // Connect and poll
    const connectResult = await concept.connectSource({
      owner: userA,
      sourceType: "Canvas",
      sourceName: "Test Canvas",
      details: canvasDetails,
    }) as ConnectSourceSuccess;
    const sourceId = connectResult.sourceAccount;

    const pollResult = await concept.pollExternalSource({
      sourceAccount: sourceId,
    }) as PollExternalSourceSuccess;

    // Identify changes (should all be new)
    const identifyResult = await concept.identifyChanges({
      sourceAccount: sourceId,
      rawExternalAssignments: pollResult.rawExternalAssignments,
    }) as IdentifyChangesSuccess;

    assertEquals(
      identifyResult.assignmentsToProcess.length,
      pollResult.rawExternalAssignments.length,
      "All assignments should be new on first sync"
    );

    // All should have null existingInternalId (new assignments)
    identifyResult.assignmentsToProcess.forEach(assignment => {
      assertEquals(assignment.existingInternalId, null, "New assignments should have null existingInternalId");
    });

    console.log(`✓ Identified ${identifyResult.assignmentsToProcess.length} new assignments`);

    // Cleanup
    await concept.disconnectSource({ sourceAccount: sourceId });
  } finally {
    await client.close();
  }
});

Deno.test("ExternalAssignmentSync - recordInternalSync and change detection", async () => {
  if (SKIP_CANVAS_TESTS) return;

  const [db, client] = await testDb();
  const concept = new ExternalAssignmentSyncConcept(db);
  const userA: User = freshID();

  try {
    const canvasDetails: ConnectionDetails = {
      apiToken: CANVAS_TOKEN!,
      baseUrl: CANVAS_URL,
    };

    // Connect and poll
    const connectResult = await concept.connectSource({
      owner: userA,
      sourceType: "Canvas",
      sourceName: "Test Canvas",
      details: canvasDetails,
    }) as ConnectSourceSuccess;
    const sourceId = connectResult.sourceAccount;

    const pollResult = await concept.pollExternalSource({
      sourceAccount: sourceId,
    }) as PollExternalSourceSuccess;

    if (pollResult.rawExternalAssignments.length === 0) {
      console.log("⚠️  No assignments in Canvas - skipping recordInternalSync test");
      await concept.disconnectSource({ sourceAccount: sourceId });
      await client.close();
      return;
    }

    const firstAssignment = pollResult.rawExternalAssignments[0];

    // Record sync for first assignment
    const internalId = freshID();
    await concept.recordInternalSync({
      sourceAccount: sourceId,
      externalId: firstAssignment.externalId,
      internalId: internalId,
      externalModificationTimestamp: firstAssignment.externalModificationTimestamp,
    });

    console.log(`✓ Recorded sync for assignment ${firstAssignment.externalId}`);

    // Verify mapping was created
    const mapped = await concept._getMappedInternalId({
      externalId: firstAssignment.externalId,
      sourceAccount: sourceId,
    }) as GetMappedInternalIdSuccess;

    assertEquals(mapped.internalId, internalId);
    console.log("✓ Mapping verified");

    // Poll again - same assignment should be detected as unchanged
    const pollResult2 = await concept.pollExternalSource({
      sourceAccount: sourceId,
    }) as PollExternalSourceSuccess;

    const identifyResult = await concept.identifyChanges({
      sourceAccount: sourceId,
      rawExternalAssignments: pollResult2.rawExternalAssignments,
    }) as IdentifyChangesSuccess;

    // First assignment should NOT be in the list (unchanged)
    const unchangedAssignment = identifyResult.assignmentsToProcess.find(
      a => a.externalId === firstAssignment.externalId
    );
    assertEquals(unchangedAssignment, undefined, "Unchanged assignment should not be in list");
    console.log("✓ Unchanged assignment correctly excluded");

    // Cleanup
    await concept.disconnectSource({ sourceAccount: sourceId });
  } finally {
    await client.close();
  }
});

Deno.test("ExternalAssignmentSync - disconnectSource removes all mappings", async () => {
  if (SKIP_CANVAS_TESTS) return;

  const [db, client] = await testDb();
  const concept = new ExternalAssignmentSyncConcept(db);
  const userA: User = freshID();

  try {
    const canvasDetails: ConnectionDetails = {
      apiToken: CANVAS_TOKEN!,
      baseUrl: CANVAS_URL,
    };

    // Connect and poll
    const connectResult = await concept.connectSource({
      owner: userA,
      sourceType: "Canvas",
      sourceName: "Test Canvas",
      details: canvasDetails,
    }) as ConnectSourceSuccess;
    const sourceId = connectResult.sourceAccount;

    const pollResult = await concept.pollExternalSource({
      sourceAccount: sourceId,
    }) as PollExternalSourceSuccess;

    // Record some syncs
    const assignments = pollResult.rawExternalAssignments.slice(0, 2);
    for (const assignment of assignments) {
      await concept.recordInternalSync({
        sourceAccount: sourceId,
        externalId: assignment.externalId,
        internalId: freshID(),
        externalModificationTimestamp: assignment.externalModificationTimestamp,
      });
    }

    console.log(`✓ Recorded ${assignments.length} syncs`);

    // Verify mappings exist
    const assignmentsBefore = await concept._getAssignmentsForSource({
      sourceAccount: sourceId,
    }) as GetAssignmentsForSourceSuccess;

    assertEquals(assignmentsBefore.assignments.length, assignments.length);
    console.log("✓ Mappings verified");

    // Disconnect
    const disconnectResult = await concept.disconnectSource({
      sourceAccount: sourceId,
    });

    assertEquals(disconnectResult, {});
    console.log("✓ Source disconnected");

    // Verify source removed
    const sourcesAfter = await concept._getSourcesForUser({
      user: userA,
    }) as GetSourcesForUserSuccess;

    assertEquals(sourcesAfter.sources.length, 0);
    console.log("✓ Source removed from database");

    // Verify all mappings removed
    const assignmentsAfterResult = await concept._getAssignmentsForSource({
      sourceAccount: sourceId,
    });

    if ("error" in assignmentsAfterResult) {
      // Expected - source doesn't exist anymore
      console.log("✓ Mappings deleted (source not found)");
    } else {
      assertEquals(assignmentsAfterResult.assignments.length, 0);
      console.log("✓ Mappings deleted");
    }
  } finally {
    await client.close();
  }
});

Deno.test("ExternalAssignmentSync - query errors", async () => {
  const [db, client] = await testDb();
  const concept = new ExternalAssignmentSyncConcept(db);

  try {
    const nonExistentSource = freshID();

    // Test _getMappedInternalId with non-existent mapping
    const result1 = await concept._getMappedInternalId({
      externalId: "non-existent",
      sourceAccount: nonExistentSource,
    }) as ErrorResult;

    assertExists(result1.error);
    console.log("✓ _getMappedInternalId returns error for non-existent mapping");

    // Test _getAssignmentsForSource with non-existent source
    const result2 = await concept._getAssignmentsForSource({
      sourceAccount: nonExistentSource,
    }) as ErrorResult;

    assertExists(result2.error);
    assertEquals(result2.error, "Source account not found");
    console.log("✓ _getAssignmentsForSource returns error for non-existent source");

    // Test disconnectSource with non-existent source
    const result3 = await concept.disconnectSource({
      sourceAccount: nonExistentSource,
    }) as ErrorResult;

    assertExists(result3.error);
    console.log("✓ disconnectSource returns error for non-existent source");
  } finally {
    await client.close();
  }
});

Deno.test("ExternalAssignmentSync - full workflow (principle trace)", async () => {
  if (SKIP_CANVAS_TESTS) return;

  const [db, client] = await testDb();
  const concept = new ExternalAssignmentSyncConcept(db);
  const userA: User = freshID();

  try {
    const canvasDetails: ConnectionDetails = {
      apiToken: CANVAS_TOKEN!,
      baseUrl: CANVAS_URL,
    };

    console.log("\n=== Full Workflow Test ===\n");

    // 1. User connects external source
    console.log("1. Connecting to Canvas...");
    const connectResult = await concept.connectSource({
      owner: userA,
      sourceType: "Canvas",
      sourceName: "Full Workflow Test",
      details: canvasDetails,
    }) as ConnectSourceSuccess;

    assertExists(connectResult.sourceAccount);
    const sourceId = connectResult.sourceAccount;
    console.log(`   ✓ Connected: ${sourceId}`);

    // 2. System fetches assignments
    console.log("\n2. Polling assignments...");
    const pollResult1 = await concept.pollExternalSource({
      sourceAccount: sourceId,
    }) as PollExternalSourceSuccess;

    console.log(`   ✓ Fetched ${pollResult1.rawExternalAssignments.length} assignments`);

    // 3. Identify new assignments
    console.log("\n3. Identifying changes...");
    const identifyResult1 = await concept.identifyChanges({
      sourceAccount: sourceId,
      rawExternalAssignments: pollResult1.rawExternalAssignments,
    }) as IdentifyChangesSuccess;

    console.log(`   ✓ Identified ${identifyResult1.assignmentsToProcess.length} new assignments`);

    // 4. Application processes and records sync
    console.log("\n4. Recording syncs...");
    const processedAssignments = identifyResult1.assignmentsToProcess.slice(0, 3);
    for (const assignment of processedAssignments) {
      const internalId = freshID();
      await concept.recordInternalSync({
        sourceAccount: sourceId,
        externalId: assignment.externalId,
        internalId: internalId,
        externalModificationTimestamp: assignment.externalModificationTimestamp,
      });
    }
    console.log(`   ✓ Recorded ${processedAssignments.length} syncs`);

    // 5. Subsequent poll should show most assignments as unchanged
    console.log("\n5. Polling again...");
    const pollResult2 = await concept.pollExternalSource({
      sourceAccount: sourceId,
    }) as PollExternalSourceSuccess;

    const identifyResult2 = await concept.identifyChanges({
      sourceAccount: sourceId,
      rawExternalAssignments: pollResult2.rawExternalAssignments,
    }) as IdentifyChangesSuccess;

    // Fewer assignments should need processing (only new/updated ones)
    console.log(`   ✓ ${identifyResult2.assignmentsToProcess.length} assignments to process (new/updated only)`);

    // 6. Verify mappings
    console.log("\n6. Verifying mappings...");
    const allMappings = await concept._getAssignmentsForSource({
      sourceAccount: sourceId,
    }) as GetAssignmentsForSourceSuccess;

    assertEquals(allMappings.assignments.length, processedAssignments.length);
    console.log(`   ✓ ${allMappings.assignments.length} mappings stored`);

    // 7. User disconnects
    console.log("\n7. Disconnecting...");
    await concept.disconnectSource({ sourceAccount: sourceId });
    console.log("   ✓ Disconnected");

    // 8. Verify cleanup
    console.log("\n8. Verifying cleanup...");
    const sourcesAfter = await concept._getSourcesForUser({ user: userA }) as GetSourcesForUserSuccess;
    assertEquals(sourcesAfter.sources.length, 0);
    console.log("   ✓ All data cleaned up");

    console.log("\n=== Full Workflow Completed Successfully ===\n");
  } finally {
    await client.close();
  }
});

Deno.test("ExternalAssignmentSync - multiple users and sources", async () => {
  if (SKIP_CANVAS_TESTS) return;

  const [db, client] = await testDb();
  const concept = new ExternalAssignmentSyncConcept(db);
  const userA: User = freshID();
  const userB: User = freshID();

  try {
    const canvasDetails: ConnectionDetails = {
      apiToken: CANVAS_TOKEN!,
      baseUrl: CANVAS_URL,
    };

    // User A connects
    const resultA = await concept.connectSource({
      owner: userA,
      sourceType: "Canvas",
      sourceName: "UserA Canvas",
      details: canvasDetails,
    }) as ConnectSourceSuccess;

    // User B connects with same sourceType and baseUrl (should succeed - different user)
    const resultB = await concept.connectSource({
      owner: userB,
      sourceType: "Canvas",
      sourceName: "UserB Canvas",
      details: canvasDetails,
    }) as ConnectSourceSuccess;

    assertExists(resultA.sourceAccount);
    assertExists(resultB.sourceAccount);
    assertNotEquals(resultA.sourceAccount, resultB.sourceAccount);
    console.log("✓ Multiple users can connect to same Canvas instance");

    // User A connects second source (different name, should succeed)
    const resultA2 = await concept.connectSource({
      owner: userA,
      sourceType: "Canvas",
      sourceName: "UserA Canvas 2",
      details: canvasDetails,
    }) as ConnectSourceSuccess;

    assertExists(resultA2.sourceAccount);
    console.log("✓ Same user can have multiple sources with different names");

    // Verify user A has 2 sources
    const sourcesA = await concept._getSourcesForUser({ user: userA }) as GetSourcesForUserSuccess;
    assertEquals(sourcesA.sources.length, 2);

    // Verify user B has 1 source
    const sourcesB = await concept._getSourcesForUser({ user: userB }) as GetSourcesForUserSuccess;
    assertEquals(sourcesB.sources.length, 1);
    console.log("✓ Sources correctly isolated by user");

    // Cleanup
    await concept.disconnectSource({ sourceAccount: resultA.sourceAccount });
    await concept.disconnectSource({ sourceAccount: resultA2.sourceAccount });
    await concept.disconnectSource({ sourceAccount: resultB.sourceAccount });
  } finally {
    await client.close();
  }
});

```
